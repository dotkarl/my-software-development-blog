---
title: "Wat Ben Ik: Een Architect of Een Ontwikkelaar?"
date: 2021-04-30T21:07:08+02:00
draft: true
comments: true
tags: []
summary: ""
---

Mijn leidinggevende stelde me onlangs de vraag: “Wil je een softwarearchitect zijn of wil je een softwareontwikkelaar zijn die zich met architectuur bezighoudt?” 

Dat vond ik een confronterende vraag, omdat deze me dwong om na te denken over de weg die ik de komende jaren in zal slaan. 

Dat is nogal een omslag van mijn gebruikelijke werkwijze. Normaliter probeer ik zoveel mogelijk van de invloeden op mijn pad te absorberen, ongeacht waar ze vandaan komen. Ik oriënteer me breed en integreer wat ik leer zo snel mogelijk in mijn dagelijkse werkzaamheden.

Het pad dat ik op die manier bewandel, ontstaat tijdens het lopen. Het is geen uitgestippeld pad. Dat is spannend en uitdagend, maar kan ook leiden tot een gebrek aan focus in mijn ontwikkeling.

Als mijn leertraject een softwarearchitectureel patroon zou hebben, welke zou het dan zijn? Een big ball of mud? Nee, dat is te streng. Ik dacht eerder aan een semigestructureerde monoliet, want mijn opleiding filosofie heeft mijn analytische vermogens genoeg gescherpt om me niet in chaos te verliezen.

Maar een potentiële softwarearchitect kan beter dan dat.

Het Scrumteam als architect

De vraag van mijn leidinggevende zette me ook aan het denken over hoe mijn invulling van een softwarearchitect eruit zou moeten zien. 

Dit is een moeilijke vraag, omdat ik op basis van incomplete kennis opereer. Mijn achtergrond in de softwareontwikkeling wordt sterk gekleurd door mijn ervaring als ontwikkelaar. Mijn eerste ingeving zou daarom zijn om architecturele vraagstukken te benaderen vanuit mijn rol als ontwikkelaar in een Scrumteam.




En, breder: hoe een softwarearchitect zich verhoudt tot een Agile omgeving waarin Scrum wordt beoefend.

De opvatting dat softwarearchitectuur en Agile softwareontwikkeling op gespannen voet staan, is een controversiële. Dat ze hand in hand gaan trouwens ook.

Feit is dat ons team, toen we ruim een jaar geleden begonnen aan een nieuwe applicatie die onze legacy code diende uit te faseren, alle regels van Scrum aan zijn laars lapte in naam van architectuur. Vóór we begonnen te coderen, dachten we ruime tijd na over de doelarchitectuur van onze applicatie. We brachten stakeholders en hun wensen in kaart, probeerden cijfers te plakken op de diverse -ilities, en tekenden diagrammen.

Heel slecht hebben we het blijkbaar niet gedaan, want na ruim een jaar ontwikkelen heeft onze applicatie nog altijd ruwweg dezelfde vorm als die we oorspronkelijk uitgetekend hadden.

Scrum-adepten zullen ons vervloeken, want Scrum kent geen Sprint 0 waarin dit soort zaken eerst op een rijtje worden gezet. Binnen Scrum is het doel om elke Sprint een werkend stuk software op te leveren.

Scrum én architectuur

Wanneer er dan tijd is om over architectuur na te denken? Cynici zouden zeggen: nooit. (En ze zouden erop wijzen dat het aandeel technische schuld sinds de algemene adoptie van Scrum in de industrie door het dak is gegaan.) Optimisten zouden zeggen: altijd. 

Ik neig naar dat laatste.

Het idee hierachter is dat de architectuur van een applicatie een emergente eigenschap is: hij ontstaat tijdens het bouwen. 

Let wel, dit betekent niet dat deze toevalligerwijs ontstaat. Een team dat zijn architectuur toevallig laat ontstaan, creëert een big ball of mud. Dat is ook een soort architectuur, maar niet het soort architectuur waar je als ontwikkelaar ook maar één regel code van wil wijzigen.

Ik geloof dat een emergente architectuur verdedigbaar is als je de complexiteit van het softwareontwikkellandschap in acht neemt. Feit is dat je op elk punt van het ontwikkelen van een applicatie opereert op basis van incomplete informatie. Maar: op elk volgend punt weet je iets meer dan op het vorige. Die extra informatie stelt je in staat om betere beslissingen te maken dan daarvóór. En dus ben je op elk punt beter in staat om een goede architectuur op te zetten om het probleem van je klant op te lossen.

Maar ja, je neemt op elk punt wel de geschiedenis van alle vorige punten mee. Die wetenschap dwingt je om je tijdens het ontwikkelen constant af te vragen: bevindt mijn code zich op het koppelvlak van twee modules? En die vraag dwingt je om je code zoveel mogelijk te scheiden. Want wat vandaag nog geen koppelvlak is, kan dat morgen wel zijn.



